<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Views with D3.js</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-F3w7mX95PdgyTmZZMECAngseQB83DfGTowi0iMjiWaeVhAn4FJkqJByhZMI3AhiU" crossorigin="anonymous">

    <style>
        /*
        make the links move to the right
        */
        #navbarNav {
            justify-content: flex-end;
        }

        /*
        spacing the header container
        */
        .container-fluid.nav-card-parent {
            margin: 20px 0;
        }

        /*
        for the test
        */
        .node {
            fill: steelblue;
            stroke: none;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1px;
        }

        /**
        responsive svg: http://thenewcode.com/744/Make-SVG-Responsive
        */

        .svg-container { 
            display: inline-block;
            position: relative;
            width: 100%;
            padding-bottom: 100%; 
            vertical-align: middle; 
            overflow: hidden; 
        }

        .svg-content { 
            display: inline-block;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>

<body>

    <header>


        <div class="container-fluid nav-card-parent">
            <div class="card">
                <div class="card-body">
                    <nav class="navbar navbar-expand-lg navbar-light bg-light">
                        <div class="container-fluid">
                            <a class="navbar-brand" href="#">WSD - Admin</a>
                            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                                data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
                                aria-label="Toggle navigation">
                                <span class="navbar-toggler-icon"></span>
                            </button>
                            <div class="collapse navbar-collapse" id="navbarNav">
                                <ul class="nav">
                                    <li class="nav-item">
                                        <a class="nav-link active" aria-current="page" href="/">chart.js</a>
                                    </li>
                                    <li class="nav-item">
                                        <a class="nav-link" href="/d3-js">D3.js</a>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </nav>
                </div>
            </div>
        </div>






    </header>

    <main>
        <section class="container-fluid">
            <p id="intro-paragraph">Please wait a couple of minutes, we're crunching the data.</p>
            <p>These views are hierarchical because the information they convey are more detailed. So making them hierarchical allows to easily trace data flow and grasp information better.</p>
        </section>

        <div class="container-fluid">
            <div class="card">

                <div class="card-body">
                    <h5 class="card-title">Sample test</h5>
                    <h6 class="card-subtitle mb-2 text-muted">Issa test</h6>
                    <div class="container main-div">
                        <div class="svg-container">
                            <svg id="test" width="" height="" class="svg-content"></svg>
                        </div>
                    </div>

                    <p class="card-text pt-5 p-3" id="chart_003_parpgraph"></p>

                    <p>
                        this is why I used this chart https://www.cc.gatech.edu/gvu/ii/sunburst/
                    </p>
                </div>
            </div>


            <div class="card">

                <div class="card-body">
                    <h5 class="card-title">Stream hosts</h5>
                    <h6 class="card-subtitle mb-2 text-muted">Down stream and upsteam host relationship. I wanted to show how the network request travel across various web hosts to generate the service report. Click on a section to expand, and the middle to collapse.</h6>
                    <div class="container main-div">
                        <div class="svg-container">
                            <svg id="a" width="" height="" class="svg-content"></svg>
                        </div>
                    </div>

                    <p class="card-text pt-5 p-3" id="chart_004_parpgraph"></p>

                    <p>
                        
                    </p>
                </div>
            </div>



            <div class="card">

                <div class="card-body">
                    <h5 class="card-title">Stream hosts [Tree]</h5>
                    <h6 class="card-subtitle mb-2 text-muted">Down stream and upsteam host. Same data but with a bird's eye view, so you can see at once the network of requests together with down stream and up steam relationships between various webhosts.</h6>
                    <div class="container main-div">
                        <div class="svg-container">
                            <svg id="b" width="" height="" class="svg-content"></svg>
                        </div>
                    </div>

                    <p class="card-text pt-5 p-3" id="chart_005_parpgraph"></p>

                    <p>
                    </p>
                </div>
            </div>


            <div class="card">

                <div class="card-body">
                    <h5 class="card-title">Stream hosts [Collapsable Tree]</h5>
                    <h6 class="card-subtitle mb-2 text-muted">Down stream and upsteam host relationship. Essentially the same view as above, but collapsable. Click the dots to expand and collapse the tree node.</h6>
                    <div class="container main-div">
                        <div class="svg-container">
                            <svg id="bb" width="" height="" class="svg-content"></svg>
                        </div>
                    </div>

                    <p class="card-text pt-5 p-3" id="chart_008_parpgraph"></p>

                    <p>
                    </p>
                </div>
            </div>





            <div class="card">

                <div class="card-body">
                    <h5 class="card-title">Stream hosts</h5>
                    <h6 class="card-subtitle mb-2 text-muted">down stream and upsteam host</h6>
                    <div class="container main-div">
                        <div class="svg-container">
                            <svg id="bd" width="" height="" class="svg-content"></svg>
                        </div>
                    </div>

                    <p class="card-text pt-5 p-3" id="chart_006_parpgraph"></p>

                    <p>
                    </p>
                </div>
            </div>


        </div>



    </main>


    <script src="https://d3js.org/d3.v7.min.js"></script>

    <script>
        let server_reponse
        
        function extractCompliantReports() {
            return server_reponse.service_reports.filter(d => d.status_text != "Not Implemented")
        }

        let data = {
            "name": "flare",
            "children": [
                {
                    "name": "analytics",
                    "children": [
                        {
                            "name": "cluster",
                            "children": [
                                { "name": "AgglomerativeCluster", "value": 3938 },
                                { "name": "CommunityStructure", "value": 3812 },
                                { "name": "HierarchicalCluster", "value": 6714 },
                                { "name": "MergeEdge", "value": 743 }
                            ]
                        },
                        {
                            "name": "graph",
                            "children": [
                                { "name": "BetweennessCentrality", "value": 3534 },
                                { "name": "LinkDistance", "value": 5731 },
                                { "name": "MaxFlowMinCut", "value": 7840 },
                                { "name": "ShortestPaths", "value": 5914 },
                                { "name": "SpanningTree", "value": 3416 }
                            ]
                        },
                        {
                            "name": "optimization",
                            "children": [
                                { "name": "AspectRatioBanker", "value": 7074 }
                            ]
                        }
                    ]
                },
                {
                    "name": "animate",
                    "children": [
                        { "name": "Easing", "value": 17010 },
                        { "name": "FunctionSequence", "value": 5842 },
                        {
                            "name": "interpolate",
                            "children": [
                                { "name": "ArrayInterpolator", "value": 1983 },
                                { "name": "ColorInterpolator", "value": 2047 },
                                { "name": "DateInterpolator", "value": 1375 },
                                { "name": "Interpolator", "value": 8746 },
                                { "name": "MatrixInterpolator", "value": 2202 },
                                { "name": "NumberInterpolator", "value": 1382 },
                                { "name": "ObjectInterpolator", "value": 1629 },
                                { "name": "PointInterpolator", "value": 1675 },
                                { "name": "RectangleInterpolator", "value": 2042 }
                            ]
                        },
                        { "name": "ISchedulable", "value": 1041 },
                        { "name": "Parallel", "value": 5176 },
                        { "name": "Pause", "value": 449 },
                        { "name": "Scheduler", "value": 5593 },
                        { "name": "Sequence", "value": 5534 },
                        { "name": "Transition", "value": 9201 },
                        { "name": "Transitioner", "value": 19975 },
                        { "name": "TransitionEvent", "value": 1116 },
                        { "name": "Tween", "value": 6006 }
                    ]
                },
                {
                    "name": "data",
                    "children": [
                        {
                            "name": "converters",
                            "children": [
                                { "name": "Converters", "value": 721 },
                                { "name": "DelimitedTextConverter", "value": 4294 },
                                { "name": "GraphMLConverter", "value": 9800 },
                                { "name": "IDataConverter", "value": 1314 },
                                { "name": "JSONConverter", "value": 2220 }
                            ]
                        },
                        { "name": "DataField", "value": 1759 },
                        { "name": "DataSchema", "value": 2165 },
                        { "name": "DataSet", "value": 586 },
                        { "name": "DataSource", "value": 3331 },
                        { "name": "DataTable", "value": 772 },
                        { "name": "DataUtil", "value": 3322 }
                    ]
                },
                {
                    "name": "display",
                    "children": [
                        { "name": "DirtySprite", "value": 8833 },
                        { "name": "LineSprite", "value": 1732 },
                        { "name": "RectSprite", "value": 3623 },
                        { "name": "TextSprite", "value": 10066 }
                    ]
                },
                {
                    "name": "flex",
                    "children": [
                        { "name": "FlareVis", "value": 4116 }
                    ]
                },
                {
                    "name": "physics",
                    "children": [
                        { "name": "DragForce", "value": 1082 },
                        { "name": "GravityForce", "value": 1336 },
                        { "name": "IForce", "value": 319 },
                        { "name": "NBodyForce", "value": 10498 },
                        { "name": "Particle", "value": 2822 },
                        { "name": "Simulation", "value": 9983 },
                        { "name": "Spring", "value": 2213 },
                        { "name": "SpringForce", "value": 1681 }
                    ]
                },
                {
                    "name": "query",
                    "children": [
                        { "name": "AggregateExpression", "value": 1616 },
                        { "name": "And", "value": 1027 },
                        { "name": "Arithmetic", "value": 3891 },
                        { "name": "Average", "value": 891 },
                        { "name": "BinaryExpression", "value": 2893 },
                        { "name": "Comparison", "value": 5103 },
                        { "name": "CompositeExpression", "value": 3677 },
                        { "name": "Count", "value": 781 },
                        { "name": "DateUtil", "value": 4141 },
                        { "name": "Distinct", "value": 933 },
                        { "name": "Expression", "value": 5130 },
                        { "name": "ExpressionIterator", "value": 3617 },
                        { "name": "Fn", "value": 3240 },
                        { "name": "If", "value": 2732 },
                        { "name": "IsA", "value": 2039 },
                        { "name": "Literal", "value": 1214 },
                        { "name": "Match", "value": 3748 },
                        { "name": "Maximum", "value": 843 },
                        {
                            "name": "methods",
                            "children": [
                                { "name": "add", "value": 593 },
                                { "name": "and", "value": 330 },
                                { "name": "average", "value": 287 },
                                { "name": "count", "value": 277 },
                                { "name": "distinct", "value": 292 },
                                { "name": "div", "value": 595 },
                                { "name": "eq", "value": 594 },
                                { "name": "fn", "value": 460 },
                                { "name": "gt", "value": 603 },
                                { "name": "gte", "value": 625 },
                                { "name": "iff", "value": 748 },
                                { "name": "isa", "value": 461 },
                                { "name": "lt", "value": 597 },
                                { "name": "lte", "value": 619 },
                                { "name": "max", "value": 283 },
                                { "name": "min", "value": 283 },
                                { "name": "mod", "value": 591 },
                                { "name": "mul", "value": 603 },
                                { "name": "neq", "value": 599 },
                                { "name": "not", "value": 386 },
                                { "name": "or", "value": 323 },
                                { "name": "orderby", "value": 307 },
                                { "name": "range", "value": 772 },
                                { "name": "select", "value": 296 },
                                { "name": "stddev", "value": 363 },
                                { "name": "sub", "value": 600 },
                                { "name": "sum", "value": 280 },
                                { "name": "update", "value": 307 },
                                { "name": "variance", "value": 335 },
                                { "name": "where", "value": 299 },
                                { "name": "xor", "value": 354 },
                                { "name": "_", "value": 264 }
                            ]
                        },
                        { "name": "Minimum", "value": 843 },
                        { "name": "Not", "value": 1554 },
                        { "name": "Or", "value": 970 },
                        { "name": "Query", "value": 13896 },
                        { "name": "Range", "value": 1594 },
                        { "name": "StringUtil", "value": 4130 },
                        { "name": "Sum", "value": 791 },
                        { "name": "Variable", "value": 1124 },
                        { "name": "Variance", "value": 1876 },
                        { "name": "Xor", "value": 1101 }
                    ]
                },
                {
                    "name": "scale",
                    "children": [
                        { "name": "IScaleMap", "value": 2105 },
                        { "name": "LinearScale", "value": 1316 },
                        { "name": "LogScale", "value": 3151 },
                        { "name": "OrdinalScale", "value": 3770 },
                        { "name": "QuantileScale", "value": 2435 },
                        { "name": "QuantitativeScale", "value": 4839 },
                        { "name": "RootScale", "value": 1756 },
                        { "name": "Scale", "value": 4268 },
                        { "name": "ScaleType", "value": 1821 },
                        { "name": "TimeScale", "value": 5833 }
                    ]
                },
                {
                    "name": "util",
                    "children": [
                        { "name": "Arrays", "value": 8258 },
                        { "name": "Colors", "value": 10001 },
                        { "name": "Dates", "value": 8217 },
                        { "name": "Displays", "value": 12555 },
                        { "name": "Filter", "value": 2324 },
                        { "name": "Geometry", "value": 10993 },
                        {
                            "name": "heap",
                            "children": [
                                { "name": "FibonacciHeap", "value": 9354 },
                                { "name": "HeapNode", "value": 1233 }
                            ]
                        },
                        { "name": "IEvaluable", "value": 335 },
                        { "name": "IPredicate", "value": 383 },
                        { "name": "IValueProxy", "value": 874 },
                        {
                            "name": "math",
                            "children": [
                                { "name": "DenseMatrix", "value": 3165 },
                                { "name": "IMatrix", "value": 2815 },
                                { "name": "SparseMatrix", "value": 3366 }
                            ]
                        },
                        { "name": "Maths", "value": 17705 },
                        { "name": "Orientation", "value": 1486 },
                        {
                            "name": "palette",
                            "children": [
                                { "name": "ColorPalette", "value": 6367 },
                                { "name": "Palette", "value": 1229 },
                                { "name": "ShapePalette", "value": 2059 },
                                { "name": "SizePalette", "value": 2291 }
                            ]
                        },
                        { "name": "Property", "value": 5559 },
                        { "name": "Shapes", "value": 19118 },
                        { "name": "Sort", "value": 6887 },
                        { "name": "Stats", "value": 6557 },
                        { "name": "Strings", "value": 22026 }
                    ]
                },
                {
                    "name": "vis",
                    "children": [
                        {
                            "name": "axis",
                            "children": [
                                { "name": "Axes", "value": 1302 },
                                { "name": "Axis", "value": 24593 },
                                { "name": "AxisGridLine", "value": 652 },
                                { "name": "AxisLabel", "value": 636 },
                                { "name": "CartesianAxes", "value": 6703 }
                            ]
                        },
                        {
                            "name": "controls",
                            "children": [
                                { "name": "AnchorControl", "value": 2138 },
                                { "name": "ClickControl", "value": 3824 },
                                { "name": "Control", "value": 1353 },
                                { "name": "ControlList", "value": 4665 },
                                { "name": "DragControl", "value": 2649 },
                                { "name": "ExpandControl", "value": 2832 },
                                { "name": "HoverControl", "value": 4896 },
                                { "name": "IControl", "value": 763 },
                                { "name": "PanZoomControl", "value": 5222 },
                                { "name": "SelectionControl", "value": 7862 },
                                { "name": "TooltipControl", "value": 8435 }
                            ]
                        },
                        {
                            "name": "data",
                            "children": [
                                { "name": "Data", "value": 20544 },
                                { "name": "DataList", "value": 19788 },
                                { "name": "DataSprite", "value": 10349 },
                                { "name": "EdgeSprite", "value": 3301 },
                                { "name": "NodeSprite", "value": 19382 },
                                {
                                    "name": "render",
                                    "children": [
                                        { "name": "ArrowType", "value": 698 },
                                        { "name": "EdgeRenderer", "value": 5569 },
                                        { "name": "IRenderer", "value": 353 },
                                        { "name": "ShapeRenderer", "value": 2247 }
                                    ]
                                },
                                { "name": "ScaleBinding", "value": 11275 },
                                { "name": "Tree", "value": 7147 },
                                { "name": "TreeBuilder", "value": 9930 }
                            ]
                        },
                        {
                            "name": "events",
                            "children": [
                                { "name": "DataEvent", "value": 2313 },
                                { "name": "SelectionEvent", "value": 1880 },
                                { "name": "TooltipEvent", "value": 1701 },
                                { "name": "VisualizationEvent", "value": 1117 }
                            ]
                        },
                        {
                            "name": "legend",
                            "children": [
                                { "name": "Legend", "value": 20859 },
                                { "name": "LegendItem", "value": 4614 },
                                { "name": "LegendRange", "value": 10530 }
                            ]
                        },
                        {
                            "name": "operator",
                            "children": [
                                {
                                    "name": "distortion",
                                    "children": [
                                        { "name": "BifocalDistortion", "value": 4461 },
                                        { "name": "Distortion", "value": 6314 },
                                        { "name": "FisheyeDistortion", "value": 3444 }
                                    ]
                                },
                                {
                                    "name": "encoder",
                                    "children": [
                                        { "name": "ColorEncoder", "value": 3179 },
                                        { "name": "Encoder", "value": 4060 },
                                        { "name": "PropertyEncoder", "value": 4138 },
                                        { "name": "ShapeEncoder", "value": 1690 },
                                        { "name": "SizeEncoder", "value": 1830 }
                                    ]
                                },
                                {
                                    "name": "filter",
                                    "children": [
                                        { "name": "FisheyeTreeFilter", "value": 5219 },
                                        { "name": "GraphDistanceFilter", "value": 3165 },
                                        { "name": "VisibilityFilter", "value": 3509 }
                                    ]
                                },
                                { "name": "IOperator", "value": 1286 },
                                {
                                    "name": "label",
                                    "children": [
                                        { "name": "Labeler", "value": 9956 },
                                        { "name": "RadialLabeler", "value": 3899 },
                                        { "name": "StackedAreaLabeler", "value": 3202 }
                                    ]
                                },
                                {
                                    "name": "layout",
                                    "children": [
                                        { "name": "AxisLayout", "value": 6725 },
                                        { "name": "BundledEdgeRouter", "value": 3727 },
                                        { "name": "CircleLayout", "value": 9317 },
                                        { "name": "CirclePackingLayout", "value": 12003 },
                                        { "name": "DendrogramLayout", "value": 4853 },
                                        { "name": "ForceDirectedLayout", "value": 8411 },
                                        { "name": "IcicleTreeLayout", "value": 4864 },
                                        { "name": "IndentedTreeLayout", "value": 3174 },
                                        { "name": "Layout", "value": 7881 },
                                        { "name": "NodeLinkTreeLayout", "value": 12870 },
                                        { "name": "PieLayout", "value": 2728 },
                                        { "name": "RadialTreeLayout", "value": 12348 },
                                        { "name": "RandomLayout", "value": 870 },
                                        { "name": "StackedAreaLayout", "value": 9121 },
                                        { "name": "TreeMapLayout", "value": 9191 }
                                    ]
                                },
                                { "name": "Operator", "value": 2490 },
                                { "name": "OperatorList", "value": 5248 },
                                { "name": "OperatorSequence", "value": 4190 },
                                { "name": "OperatorSwitch", "value": 2581 },
                                { "name": "SortOperator", "value": 2023 }
                            ]
                        },
                        { "name": "Visualization", "value": 16540 }
                    ]
                }
            ]
        }

        function recursiveCheckForChildren(_input, _depth) {
            // check if children exists and check depth, and include element, or sth
            while (_input.children && Array.isArray(_input.children)) {
                
            }
            if (_input.children && Array.isArray(_input.children)) { // check for children_names
                
            } else {
                
            }
        }


        let format = d3.format(",d")
        let color = d3.scaleOrdinal(d3.quantize(d3.interpolateRainbow, data.children.length + 1))
        let partition = data => {
            const root = d3.hierarchy(data)
                .sum(d => d.value)
                .sort((a, b) => b.value - a.value);
            return d3.partition()
                .size([2 * Math.PI, root.height + 1])
                (root);
        }
        let width = 932
        let radius = width / 6
        let arc = d3.arc()
            .startAngle(d => d.x0)
            .endAngle(d => d.x1)
            .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
            .padRadius(radius * 1.5)
            .innerRadius(d => d.y0 * radius)
            .outerRadius(d => Math.max(d.y0 * radius, d.y1 * radius - 1));
        function drawTestZoomableSunburstChart() {
            const root = partition(data);

            root.each(d => d.current = d);

            const svg = d3.create("svg")
                .attr("viewBox", [0, 0, width, width])
                .style("font", "10px sans-serif");

            const g = svg.append("g")
                .attr("transform", `translate(${width / 2},${width / 2})`);

            const path = g.append("g")
                .selectAll("path")
                .data(root.descendants().slice(1))
                .join("path")
                .attr("fill", d => { while (d.depth > 1) d = d.parent; return color(d.data.name); })
                .attr("fill-opacity", d => arcVisible(d.current) ? (d.children ? 0.6 : 0.4) : 0)
                .attr("d", d => arc(d.current));

            path.filter(d => d.children)
                .style("cursor", "pointer")
                .on("click", clicked);

            path.append("title")
                .text(d => `${d.ancestors().map(d => d.data.name).reverse().join("/")}\n${format(d.value)}`);

            const label = g.append("g")
                .attr("pointer-events", "none")
                .attr("text-anchor", "middle")
                .style("user-select", "none")
                .selectAll("text")
                .data(root.descendants().slice(1))
                .join("text")
                .attr("dy", "0.35em")
                .attr("fill-opacity", d => +labelVisible(d.current))
                .attr("transform", d => labelTransform(d.current))
                .text(d => d.data.name);

            const parent = g.append("circle")
                .datum(root)
                .attr("r", radius)
                .attr("fill", "none")
                .attr("pointer-events", "all")
                .on("click", clicked);

            function clicked(event, p) {
                parent.datum(p.parent || root);

                root.each(d => d.target = {
                    x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                    x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                    y0: Math.max(0, d.y0 - p.depth),
                    y1: Math.max(0, d.y1 - p.depth)
                });

                const t = g.transition().duration(750);

                // Transition the data on all arcs, even the ones that aren’t visible,
                // so that if this transition is interrupted, entering arcs will start
                // the next transition from the desired position.
                path.transition(t)
                    .tween("data", d => {
                        const i = d3.interpolate(d.current, d.target);
                        return t => d.current = i(t);
                    })
                    .filter(function (d) {
                        return +this.getAttribute("fill-opacity") || arcVisible(d.target);
                    })
                    .attr("fill-opacity", d => arcVisible(d.target) ? (d.children ? 0.6 : 0.4) : 0)
                    .attrTween("d", d => () => arc(d.current));

                label.filter(function (d) {
                    return +this.getAttribute("fill-opacity") || labelVisible(d.target);
                }).transition(t)
                    .attr("fill-opacity", d => +labelVisible(d.target))
                    .attrTween("transform", d => () => labelTransform(d.current));
            }

            function arcVisible(d) {
                return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0;
            }

            function labelVisible(d) {
                return d.y1 <= 3 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03;
            }

            function labelTransform(d) {
                const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
                const y = (d.y0 + d.y1) / 2 * radius;
                return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
            }

            return svg.node();
        }

        d3.select("#test").node().append(drawTestZoomableSunburstChart()); // https://stackoverflow.com/a/25518977/9259701

        // maybe continue here https://www.tutorialsteacher.com/d3js/create-bar-chart-using-d3js
        
        // should I make uncompliant service reports complaint ???


        let format1 = d3.format(",d")
        let color1 = d3.scaleOrdinal(d3.quantize(d3.interpolateRainbow, data.children.length + 1))
        let partition1 = data => { // https://github.com/d3/d3-hierarchy/blob/v3.0.1/README.md#partition
            const root = d3.hierarchy(data)
                .sum(d => { // https://github.com/d3/d3-hierarchy/blob/v3.0.1/README.md#node_sum
                    // console.log('?sum ?', d);
                    // check for Map also
                    if (Array.isArray(d) && Array.isArray(d[1])) {
                        return d[1][0].id
                    } else if (Array.isArray(d) && d[1] instanceof Map) {
                        return d[1].get('localhost')[0].host.id
                    } else {
                        return d.host.id
                    }
                    
                })
                .sort((a, b) => {
                    return b.data.completed_at > a.data.completed_at
                });
            return d3.partition()
                .size([2 * Math.PI, root.height + 1])
                (root);
        }
        let width1 = 932
        let radius1 = width1 / 6
        let arc1 = d3.arc()
            .startAngle(d => {
                // console.log('?11 x0', d);
                return d.x0
            })
            .endAngle(d => {
                // console.log('?22 x1', d);
                return Number.isNaN(d.x1) ? 0 : d.x1 // terrible fix 
            })
            .padAngle(d => { // what about when x.x1 was NaN
                return Math.min((d.x1 - d.x0) / 2, 0.005)
            })
            .padRadius(radius1 * 1.5)
            .innerRadius(d => {
                // console.log('?33 y0', d);
                return d.y0 * radius1
            })
            .outerRadius(d => {
                // console.log('?44 y1', d);
                return Math.max(d.y0 * radius1, d.y1 * radius1 - 1)
            });

        function drawZoomableSunburstChart() {

            /*

            const group_root = d3.group(extractCompliantReports(), d => d.host.upstream_host)
            // console.log("group_root??? <<<", group_root);

            const hierarchy_root = d3.hierarchy(group_root);
            // console.log("hierarchy_root >>>>", hierarchy_root);

            const root = tree3(hierarchy_root);
            
            
            */

            // use only services that use the service report api
            
            // server_reponse.service_reports
            // gets the group of names
            const group_root = d3.group(server_reponse.service_reports, d => d.host.upstream_host) // extractCompliantReports()
            console.log("group_root???", group_root);

            const hierarchy_root = d3.hierarchy(group_root);
            console.log("hierarchy_root+++++", hierarchy_root);

            const root = partition1(group_root);

            console.log('root ?', root);

            root.each(d => d.current = d);

            const svg = d3.create("svg")
                .attr("viewBox", [0, 0, width1, width1])
                .style("font", "10px sans-serif");

            const g = svg.append("g")
                .attr("transform", `translate(${width1 / 2},${width1 / 2})`);

            const path = g.append("g")
                .selectAll("path")
                .data(root.descendants().slice(1))
                .join("path")
                .attr("fill", d => { 
                    while (d.depth > 1) {
                        d = d.parent
                    };
                    return color1(d.data[0]); 
                })
                .attr("fill-opacity", d => arcVisible(d.current) ? (d.children ? 0.6 : 0.4) : 0)
                .attr("d", d => {
                    // console.log("backkky", d);
                    return arc1(d.current)
                });

            path.filter(d => d.children)
                .style("cursor", "pointer")
                .on("click", clicked);

            path.append("title")
                .text(d => `${d.ancestors().map(d => {
                    // console.log('i know title', d);
                    if (Array.isArray(d.data)) {
                        return d.data[0]
                    } else {
                        return d.data.host.name
                    }
                })}`);
                    // .reverse()
                    // .join("/")}\n${Array.isArray(d.data) ? d.data[0] : d.data.host.name}`); // change here ...

            const label = g.append("g")
                .attr("pointer-events", "none")
                .attr("text-anchor", "middle")
                .style("user-select", "none")
                .selectAll("text")
                .data(root.descendants().slice(1))
                .join("text")
                .attr("dy", "0.35em")
                .attr("fill-opacity", d => +labelVisible(d.current))
                .attr("transform", d => {
                    // console.log('[]][][]', d);
                    return labelTransform(d.current)
                })
                .text(d => {
                    // console.log('what\'s d?', d);
                    if (Array.isArray(d.data)) {
                        return d.data[0]
                    } else {
                        return d.data.host.name
                    }
                    // useful for fishing our un-compliant service report
                    // try {
                        
                    // } catch (error) {
                    //     console.log('causing err', d);
                    //     return d.data.host.upstream_host
                    // }
                    
                }); // change here too
            // console.log('label ??', label);

            const parent = g.append("circle")
                .datum(root)
                .attr("r", radius1)
                .attr("fill", "none")
                .attr("pointer-events", "all")
                .on("click", clicked);

            function clicked(event, p) {
                parent.datum(p.parent || root);


                console.log("over the top", p, root);
                root.each(d => d.target = {
                    x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                    x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                    y0: Math.max(0, d.y0 - p.depth),
                    y1: Math.max(0, d.y1 - p.depth)
                });

                const t = g.transition().duration(750);

                // Transition the data on all arcs, even the ones that aren’t visible,
                // so that if this transition is interrupted, entering arcs will start
                // the next transition from the desired position.
                path.transition(t)
                    .tween("data", d => {
                        const i = d3.interpolate(d.current, d.target);
                        // console.log("what is data", d);
                        return t => d.current = i(t);
                    })
                .filter(function(d) {
                    return +this.getAttribute("fill-opacity") || arcVisible(d.target);
                })
                    .attr("fill-opacity", d => arcVisible(d.target) ? (d.children ? 0.6 : 0.4) : 0)
                    .attrTween("d", d => () => arc(d.current));

                label.filter(function(d) {
                    return +this.getAttribute("fill-opacity") || labelVisible(d.target);
                }).transition(t)
                    .attr("fill-opacity", d => +labelVisible(d.target))
                    .attrTween("transform", d => () => labelTransform(d.current));
            }
            
            function arcVisible(d) {
                return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0;
            }

            function labelVisible(d) {
                return d.y1 <= 3 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03;
            }

            function labelTransform(d) {
                const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
                const y = (d.y0 + d.y1) / 2 * radius;
                return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
            }

            // console.log('svg node', svg.node());

            return svg.node();
        }


        // https://stackoverflow.com/questions/17497938/are-there-any-online-tools-to-test-svg-paths

        let width3 = 954;
        tree3 = data => {
            const root = d3.hierarchy(data);
            root.dx = 10;
            root.dy = width3 / (root.height + 1);
            return d3.tree().nodeSize([root.dx, root.dy])(root);
        }

        // https://observablehq.com/@d3/tidy-tree
        function tidyTree() {

            const group_root = d3.group(server_reponse.service_reports, d => d.host.upstream_host) // extractCompliantReports()
            // console.log("group_root??? <<<", group_root);

            const hierarchy_root = d3.hierarchy(group_root);
            // console.log("hierarchy_root >>>>", hierarchy_root);

            const root = tree3(hierarchy_root);

            let x0 = Infinity;
            let x1 = -x0;
            root.each(d => {
                if (d.x > x1) x1 = d.x;
                if (d.x < x0) x0 = d.x;
            });

            const svg = d3.create("svg")
                .attr("viewBox", [0, 0, width3, x1 - x0 + root.dx * 2]);

            const g = svg.append("g")
                .attr("font-family", "sans-serif")
                .attr("font-size", 10)
                .attr("transform", `translate(${root.dy / 3},${root.dx - x0})`);
            
            const link = g.append("g")
            .attr("fill", "none")
            .attr("stroke", "#555")
            .attr("stroke-opacity", 0.4)
            .attr("stroke-width", 1.5)
            .selectAll("path")
            .data(root.links())
            .join("path")
                .attr("d", d3.linkHorizontal()
                    .x(d => d.y)
                    .y(d => d.x));

            const node = g.append("g")
                .attr("stroke-linejoin", "round")
                .attr("stroke-width", 3)
            .selectAll("g")
            .data(root.descendants())
            .join("g")
                .attr("transform", d => `translate(${d.y},${d.x})`);

            node.append("circle")
                .attr("fill", d => d.children ? "#555" : "#999")
                .attr("r", 2.5);

            node.append("text")
                .attr("dy", "0.31em")
                .attr("x", d => d.children ? -6 : 6)
                .attr("text-anchor", d => d.children ? "end" : "start")
                .text(d => {
                    // console.log("?mob?", d);
                    if (Array.isArray(d.data.data)) {
                        return d.data.data[0]
                    } else {
                        return d.data.data.host.name
                    }
                })
            .clone(true).lower()
                .attr("stroke", "white");

            return svg.node();
        }

        


        // -- here's another tree

        // https://observablehq.com/@d3/collapsible-tree

        let margin5 = {top: 10, right: 120, bottom: 10, left: 40}
        let width5 = 928
        let dy5 = 154.66666666666666 // width / 6
        let dx5 = 10
        let tree5 = d3.tree().nodeSize([dx5, dy5])
        let diagonal5 = d3.linkHorizontal().x(d => d.y).y(d => d.x)

        function drawCollapsibleTree() {

            const group_root = d3.group(server_reponse.service_reports, d => d.host.upstream_host) // extractCompliantReports()
            // console.log("group_root??? <<<", group_root);

            const hierarchy_root = d3.hierarchy(group_root);
            // console.log("hierarchy_root >>>>", hierarchy_root);

            const root = d3.hierarchy(hierarchy_root);

            // const test_root = d3.hierarchy(data);

            root.x0 = dy5 / 2;
            root.y0 = 0;

            // test_root.descendants().forEach((d, i) => {
            //     d.id = i;
            //     d._children = d.children;
            //     console.log('tes name.lenght ?', d);
            //     if (d.depth && d.data.name.length !== 7) d.children = null;
            // });
            root.descendants().forEach((d, i) => {
                d.id = i;
                d._children = d.children;
                // console.log('name.lenght ?', d);
                // d.data.data[0] ?? 
                // if (d.depth && d.data.name.length !== 7) d.children = null;
            });

            const svg = d3.create("svg")
                .attr("viewBox", [-margin5.left, -margin5.top, width5, dx5])
                .style("font", "10px sans-serif")
                .style("user-select", "none");

            const gLink = svg.append("g")
                .attr("fill", "none")
                .attr("stroke", "#555")
                .attr("stroke-opacity", 0.4)
                .attr("stroke-width", 1.5);

            const gNode = svg.append("g")
                .attr("cursor", "pointer")
                .attr("pointer-events", "all");

            function update(source) {
                const duration = d3.event && d3.event.altKey ? 2500 : 250;
                const nodes = root.descendants().reverse();
                const links = root.links();

                // Compute the new tree layout.
                tree5(root);

                let left = root;
                let right = root;
                root.eachBefore(node => {
                if (node.x < left.x) left = node;
                if (node.x > right.x) right = node;
                });

                const height = right.x - left.x + margin5.top + margin5.bottom;

                const transition = svg.transition()
                    .duration(duration)
                    .attr("viewBox", [-margin5.left, left.x - margin5.top, width5, height])
                    .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));

                // Update the nodes…
                const node = gNode.selectAll("g")
                .data(nodes, d => d.id);

                // Enter any new nodes at the parent's previous position.
                const nodeEnter = node.enter().append("g")
                    .attr("transform", d => `translate(${source.y0},${source.x0})`)
                    .attr("fill-opacity", 0)
                    .attr("stroke-opacity", 0)
                    .on("click", (event, d) => {
                    d.children = d.children ? null : d._children;
                    update(d);
                    });

                nodeEnter.append("circle")
                    .attr("r", 2.5)
                    .attr("fill", d => d._children ? "#555" : "#999")
                    .attr("stroke-width", 10);

                nodeEnter.append("text")
                    .attr("dy", "0.31em")
                    .attr("x", d => d._children ? -6 : 6)
                    .attr("text-anchor", d => d._children ? "end" : "start")
                    .text(d => {
                        // console.log('===', d);
                        if (Array.isArray(d.data.data)) {
                            return d.data.data[0]
                        } else {
                            return d.data.data.host.name
                        }
                        
                    })
                .clone(true).lower()
                    .attr("stroke-linejoin", "round")
                    .attr("stroke-width", 3)
                    .attr("stroke", "white");

                // Transition nodes to their new position.
                const nodeUpdate = node.merge(nodeEnter).transition(transition)
                    .attr("transform", d => `translate(${d.y},${d.x})`)
                    .attr("fill-opacity", 1)
                    .attr("stroke-opacity", 1);

                // Transition exiting nodes to the parent's new position.
                const nodeExit = node.exit().transition(transition).remove()
                    .attr("transform", d => `translate(${source.y},${source.x})`)
                    .attr("fill-opacity", 0)
                    .attr("stroke-opacity", 0);

                // Update the links…
                const link = gLink.selectAll("path")
                .data(links, d => d.target.id);

                // Enter any new links at the parent's previous position.
                const linkEnter = link.enter().append("path")
                    .attr("d", d => {
                    const o = {x: source.x0, y: source.y0};
                    return diagonal5({source: o, target: o});
                    });

                // Transition links to their new position.
                link.merge(linkEnter).transition(transition)
                    .attr("d", diagonal5);

                // Transition exiting nodes to the parent's new position.
                link.exit().transition(transition).remove()
                    .attr("d", d => {
                    const o = {x: source.x, y: source.y};
                    return diagonal5({source: o, target: o});
                    });

                // Stash the old positions for transition.
                root.eachBefore(d => {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });
            }

            update(root);

            return svg.node();
        }
        
        

        // use foreignObject to wrap text in SVG

        /*
            how about we show the average time a request completion time
        */
        // https://observablehq.com/@d3/zoomable-icicle


        let height2 = 1200
        let width2 = 975

        let partition2 = data => {
            const root = d3.hierarchy(data)
                .sum(d => {
                    // console.log('summm', d);
                    return d.data[1] // d.value

                    // copying
                    // if (Array.isArray(d) && Array.isArray(d[1])) {
                    //     return d[1][0].id
                    // } else if (Array.isArray(d) && d[1] instanceof Map) {
                    //     return d[1].get('localhost')[0].host.id
                    // } else {
                    //     return d.host.id
                    // }
                })
                .sort((a, b) => {
                    return b.data.completed_at > a.data.completed_at
                });  
            return d3.partition()
                .size([height2, (root.height + 1) * width2 / 3])
                (root);
        }
        color2 = d3.scaleOrdinal(d3.quantize(d3.interpolateRainbow, data.children.length + 1))

        function tryRollUp() {
            let _rollUp = d3.rollup(server_reponse.service_reports, v => v.length, d => d.host.upstream_host); // extractCompliantReports() | server_reponse.service_reports
            console.log('rolled up data', _rollUp);

            let _hie = d3.hierarchy(_rollUp);
            console.log('hierarchy', _hie);

            const root = partition2(_hie);
            let focus = root;

            const svg = d3.create("svg")
                .attr("viewBox", [0, 0, width2, height2])
                .style("font", "10px sans-serif");

            const cell = svg
                .selectAll("g")
                .data(root.descendants())
                .join("g")
                .attr("transform", d => `translate(${d.y0},${d.x0})`);

            const rect = cell.append("rect")
                .attr("width", d => d.y1 - d.y0 - 1)
                .attr("height", d => rectHeight(d))
                .attr("fill-opacity", 0.6)
                .attr("fill", d => {
                    if (!d.depth) return "#ccc";
                    while (d.depth > 1) d = d.parent;
                    // console.log('? coloar ?', d);
                    return color2(d.data.data[0]);
                })
                .style("cursor", "pointer")
                .on("click", clicked);

            const text = cell.append("text")
                .style("user-select", "none")
                .attr("pointer-events", "none")
                .attr("x", 4)
                .attr("y", 13)
                .attr("fill-opacity", d => +labelVisible(d));

            text.append("tspan")
                .text(d => {
                    // console.log('tspan', d);
                    return d.data.data[0] ? d.data.data[0] : 'root'
                });

            const tspan = text.append("tspan")
                .attr("fill-opacity", d => labelVisible(d) * 0.7)
                .text(d => `${d.data.data[0] ? d.data.data[0] : 'root'}`);

            cell.append("title")
                .text(d => `${d.ancestors().map(d => {
                    return d.data.data[0] ? d.data.data[0] : 'root'
                }).reverse()}`);

            function clicked(event, p) {
                focus = focus === p ? p = p.parent : p;

                // put a try catch block here, for when they click the root block

                root.each(d => d.target = {
                    x0: (d.x0 - p.x0) / (p.x1 - p.x0) * height2,
                    x1: (d.x1 - p.x0) / (p.x1 - p.x0) * height2,
                    y0: d.y0 - p.y0,
                    y1: d.y1 - p.y0
                });

                const t = cell.transition().duration(750)
                    .attr("transform", d => `translate(${d.target.y0},${d.target.x0})`);

                rect.transition(t).attr("height", d => rectHeight(d.target));
                text.transition(t).attr("fill-opacity", d => +labelVisible(d.target));
                tspan.transition(t).attr("fill-opacity", d => labelVisible(d.target) * 0.7);
            }
            
            function rectHeight(d) {
                return d.x1 - d.x0 - Math.min(1, (d.x1 - d.x0) / 2);
            }

            function labelVisible(d) {
                return d.y1 <= width && d.y0 >= 0 && d.x1 - d.x0 > 16;
            }

            console.log('wow', svg.node());
            
            return svg.node();

            
        }

        



        // ---- TIME charts ...

        // https://observablehq.com/@d3/slope-chart
        
        // 2nd time

        // https://observablehq.com/@d3/box-plot



        

        function drawCharts() {
            document.getElementById('intro-paragraph').textContent = ''
            let spinners = document.getElementsByClassName('spinner-border')
            for (let index = 0; index < spinners.length; index++) {
                spinners[index].setAttribute('style', 'display:none;'); // remove() // 
            }

            d3.select("#a").node().append(drawZoomableSunburstChart());

            d3.select("#bb").node().append(drawCollapsibleTree());

            d3.select("#bd").node().append(tryRollUp());

            d3.select("#b").node().append(tidyTree());
        }

        // let's cache result. only fetch new data if it's older than 15 mins // a slick update would be auto updating based on custom set time
        if(!sessionStorage.getItem('wsd-service-reports') || (sessionStorage.getItem('wsd-service-reports') && Date.now() - new Date(JSON.parse(sessionStorage.getItem('wsd-service-reports'))["completed_at"]).getTime() > (900000 + 900000 + 900000)) ) {
            fetch('http://localhost:8088/service-report') // call live url
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json()
            })
            .then(data => {
                console.log('fetched data')
                server_reponse = data
                sessionStorage.setItem('wsd-service-reports', JSON.stringify(data));
            }).then(() => {
                // hide loaders and helper text
                drawCharts();

                console.log('Hi. Just drew the charts. Look at them, not me. :)');
            }).catch((err) => {
                // also use bootstrap alerts
                document.getElementById('intro-paragraph').textContent = 'An error happened while fetching data. Please reload page.'
                console.log('Ouch. An error happened while fetching data, and drawing charts', err) // todo: maybe remove the loader ... really shd show alerts
            });
        } else {
            server_reponse = JSON.parse(sessionStorage.getItem('wsd-service-reports'))
            drawCharts();

            console.log('Used cached data gotten at', new Date(JSON.parse(sessionStorage.getItem('wsd-service-reports'))["completed_at"]));
        }


    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-/bQdsTh/da6pkI1MST/rWKFNjaCP5gBSY4sEBT38Q/9RBh9AH40zEOg7Hlq2THRZ"
        crossorigin="anonymous"></script>
</body>

</html>